# 이 문제는 카운팅정렬을 검색해서 풀어보게 되었는데 우리가 익히아는
# 평범한 카운팅 정렬을 썼다가는 하나같이 나사가 빠진 백준 문제 특성상 아주
# 경악스러운 메모리 한계설정에 메모리 초과 폭격을 당한다.
# 카운팅 정렬의 기본 포맷은 문제에서 제시한 정렬안된 리스트 하나
# 정렬을 위해 갯수(count)를 입력해둘 리스트 하나
# 마지막으로 정렬된 리스트하나 총 세가지 리스트가 필요하다고 생각했는데
# 메모리 절약을 위해서 리스트를 생략할 고민을 해야한다.

# 카운팅 정렬은 해당 숫자를 '인덱스'로 사용하여 카운팅 리스트에
# 해당 숫자가 몇 개 있는지 기록해둔다.
# 그렇다면 카운팅 리스트에 우린 인덱스가 해당 숫자이고, 인덱스에 할당된 value가 해당 숫자가
# 몇개 있는지 알 수 있다. 뭔말알?
# 카운팅 정렬을 만들기만 하면 그정보를 토대로
# 정렬해서 보일 수 있단얘기다.... 세 개의 리스트는 필요도 없다.
# 게시판을 참조하고 한번놀라고 서치해서 솔루션 찾고 두번 놀랐다.

import sys

input = sys.stdin.readline 

N = int(input())
counts = [0] * (10000+1) # 각 숫자를 인덱스로 활용하여 value는 해당 숫자의 갯수

for _ in range(N):
    num = int(input())
    counts[num] += 1 # 해당 숫자에 대한 갯수를 추가해준다.
 
for i in range(len(counts)): # 10000까지의 숫자를 돌며
    for j in range(counts[i]): # 이 숫자가 있으면 그 갯수만큼
        print(i) # 해당 숫자를 출력해준다.
